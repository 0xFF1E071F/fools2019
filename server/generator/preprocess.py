import glob
import hashlib
import configparser
import os.path
from datetime import datetime

import augment
import logger

import generator.util as util
import generator.randomizer as randomizer
from config import SAV_DIRECTORY

TAG = "CompilerPreProcess"

FILE_HEADER = b'''
; ===============================================================
; TheZZAZZGlitch's April Fools Event 2019 - Autogenerated
; ===============================================================
; This file was generated automatically. Do not modify it. Any
; changes will be reverted upon rebuilding.
; Instead, change the corresponding file in `templates/`.
; ===============================================================
; Some extra lines for extra discouragement.
''' + b'''; DO NOT EDIT!
''' * 100 + b'''; I think you get the point.
; ===============================================================
'''.strip()

def directive_basic_mon(state, args, cur):
    return state['rnd'].basic_mon()

def directive_rnd_basic_mon(state, args, cur):
    return state['rnd'].repeatable_basic_mon(int(args[0]))

def directive_first_stage_mon(state, args, cur):
    return state['rnd'].first_stage_mon()

def directive_rnd(state, args, cur):
    return b"%i" % state['rnd'].randrange(int(args[0]), int(args[1]))

def directive_current_kingdom(state, args, cur):
    return bytes(state['session']['current_kingdom'], 'ascii')

def directive_fun_value(state, args, cur):
    return bytes(str(state['session']['fun']), 'ascii')

def directive_current_kingdom_name(state, args, cur):
    return bytes(state['meta']['Info']['KingdomName'], 'ascii')

def directive_align(state, args, cur):
    pad_size = (int(args[0]) - len(cur)) // 2
    return b" " * pad_size + cur

def directive_fillchar(state, args, cur):
    if len(cur) % 2 == 1:
        cur += args[0]
    return cur

def directive_poke_charset(state, args, cur):
    return b','.join([b"%i" % x for x in util.to_standard_charset_unterminated(cur)])

def directive_current_kingdom_version(state, args, cur):
    return bytes(state['meta']['Info']['KingdomVersion'], 'ascii')

def directive_current_kingdom_is_save_allowed(state, args, cur):
    return bytes(str(state['meta']['Info']['SaveAllowedImmediately']), 'ascii')

def directive_current_timestamp(state, args, cur):
    return bytes(datetime.utcnow().strftime(r"%d.%m %H:%M:%S UTC"), 'ascii')

def directive_current_save_id(state, args, cur):
    return b','.join([bytes(str(i), 'ascii') for i in state['session']['current_save_id']])

def directive_current_respawn(state, args, cur):
    return bytes(state['meta']['Info']['Respawn'], 'ascii')

def directive_starter_species(state, args, cur):
    return bytes(state['session']['starter_species'], 'ascii')

def directive_augment(state, args, cur):
    key = args[0].decode('ascii')
    return bytes(state['augments'][key], 'ascii')

def directive_capitalize(state, args, cur):
    return cur.capitalize()

def directive_upper(state, args, cur):
    return cur.upper()

def directive_lv_rel(state, args, cur):
    try:
        l = max([x['level'] for x in state['session']['current_save']['party']])
        l += int(args[0])
    except ValueError:
        l = 20 + int(args[0])
    l = min(255, l)
    return bytes(str(l), 'ascii')

def directive_if_fun_between(state, args, cur):
    r = int(args[0]) <= state['session']['fun'] <= int(args[1])
    state['status']['last_result'] = r
    return b""

def directive_if_continued(state, args, cur):
    return b"" if state['status']['last_result'] else b"; "

def directive_else(state, args, cur):
    state['status']['last_result'] = not state['status']['last_result']
    return b""

def directive_current_roof_tileset(state, args, cur):
    return bytes(str(state['meta']['Info']['RoofGraphics']), 'ascii')

def directive_concat(state, args, cur):
    return cur + args[0].replace(b"_", b" ")

def directive_rpad(state, args, cur):
    return cur.ljust(int(args[0]), b" ")

DIRECTIVES = {
    "basic_mon": (directive_basic_mon, 0),
    "rep_mon": (directive_basic_mon, 0),
    "rnd_basic_mon": (directive_rnd_basic_mon, 1),
    "first_stage_mon": (directive_first_stage_mon, 0),
    "lv": (directive_rnd, 2),
    "rnd": (directive_rnd, 2),
    "current_kingdom": (directive_current_kingdom, 0),
    "fun_value": (directive_fun_value, 0),
    "current_kingdom_name": (directive_current_kingdom_name, 0),
    "align": (directive_align, 1),
    "fillchar": (directive_fillchar, 1),
    "poke_charset": (directive_poke_charset, 0),
    "current_kingdom_version": (directive_current_kingdom_version, 0),
    "current_kingdom_is_save_allowed": (directive_current_kingdom_is_save_allowed, 0),
    "current_timestamp": (directive_current_timestamp, 0),
    "current_save_id": (directive_current_save_id, 0),
    "current_respawn": (directive_current_respawn, 0),
    "starter_species": (directive_starter_species, 0),
    "augment": (directive_augment, 1),
    "capitalize": (directive_capitalize, 0),
    "upper": (directive_upper, 0),
    "lv_rel": (directive_lv_rel, 1),
    "if_fun_between": (directive_if_fun_between, 2),
    "else": (directive_else, 0),
    "*": (directive_if_continued, 0),
    "current_roof_tileset": (directive_current_roof_tileset, 0),
    "concat": (directive_concat, 1),
    "rpad": (directive_rpad, 1)
}

def parse_directive(directives, state):
    d = [x.replace(b"'", b"") for x in directives.split(b" ")]
    result = ""
    while d:
        d[0] = d[0].decode('ascii')
        if d[0] not in DIRECTIVES:
            raise RuntimeError("unknown directive %s" % repr(d))
        proc, argc = DIRECTIVES[d[0]]
        result = proc(state, d[1:1+argc], result)
        d = d[1+argc:]
    return result

def perform(session):
    cur_kingdom = session['current_kingdom']
    augments = augment.get_all()
    metadata = configparser.ConfigParser()
    metadata.read(SAV_DIRECTORY + "/template/maps/" + cur_kingdom + "/meta.txt")
    rnd = randomizer.Randomizer(session['user'], cur_kingdom)
    files_to_process = [
        {
            "from": list(glob.iglob(SAV_DIRECTORY + '/template/maps/' + cur_kingdom + '/*.*', recursive=True)),
            "to": SAV_DIRECTORY + "/maps/"
        },
        {
            "from": list(glob.iglob(SAV_DIRECTORY + '/template/*.*')),
            "to": SAV_DIRECTORY + "/"
        }
    ]
    for f in files_to_process:
        status = {
            'last_result': False
        }
        for source_file in f["from"]:
            target_file = f["to"] + os.path.basename(source_file).replace("template/", "/").replace(".asmp",".asm")
            extension = source_file.split(".")[-1]
            if extension != 'asmp':
                logger.log(TAG, 'cp "%s" "%s"' % (source_file, target_file))
                os.system('cp "%s" "%s"' % (source_file, target_file))
                continue
            logger.log(TAG, "processing `%s` -> `%s`" % (source_file, target_file))
            with open(source_file, 'rb') as fp:
                d = fp.read()
            while 1:
                at = d.find(b"{")
                if at < 0: break
                directive = d[at+1:d.find(b"}", at+1)]
                result = parse_directive(directive, {
                    'rnd': rnd,
                    'session': session,
                    'augments': augments,
                    'meta': metadata,
                    'status': status
                })
                d = d.replace(b"{" + directive + b"}", result, 1)
            with open(target_file, 'wb') as fp:
                fp.write(FILE_HEADER + b"\n\n")
                fp.write(d)

if __name__ == "__main__":
    from mocksession import MOCK_SESSION
    print("*** map preprocessor for fools2019")
    print("*** TheZZAZZGlitch 2018-2019")
    perform(MOCK_SESSION)
